# 実装メモ

---

disabled

first-mate #71でdisabledを実装してないのにvscodeが動くのは、patternsが空のBeginEndRuleを削除するルールがあるためだった。たとえ中身が空でもbegin自体で作用があるのでこれはだめな気がするけど・・・。

---

キャプチャ内部パターン

キャプチャした範囲を文字列として、行頭^と行末$がマッチしないとだめっぽい。正規表現から見た位置と、本当の行での位置がずれるので、補正レイヤーが必要

---

BeginWhileの処理

beginのマッチ
stateに追加して、次の行から作用する

---

ゼロ幅トークン処理

行末だけ改行手前までトークン切り出し&特別にゼロ幅を許可して、最後の整形処理で末尾のゼロ幅トークンを除去、ただしトークン列が無くなる場合は保護、はみ出したトークンは改行手前まで縮める

ようわからんがこれでテストは通るようになった。

---

無限ループ

無限ループを検出したら行末まで食べてしまう。

endルールによってステートをpopしたとき、対応するbeginの突入位置と同じならループしている。
beginルールによってステートをpushするとき、同じルールをpushしようとしていて、かつ、位置が変わっていないなら、ループしている。このルール自体がだめだけどpopせずにそのままスキップしても良さそう。どうせ復旧しても不安定だし。
begin-whileでも同様だけどまだ実装していない。
matchルールの前後で位置が変わっていない場合、またマッチしてしまうのでループしている。

とりあえず first-mate test38 だけ対応する

first-mate test47で進まないbeginループに対応

first-mate test73でend直後の検出に対応

begin-whileが残ってる

---

状態遷移

ScopeRuleへの突入
  begin部分の処理
    captureごとの内側のpatterns
  contentNameの適用
    内側のpatterns
  end部分の処理
    captureごとの内側のpatterns

MatchRuleのヒット
  captureごとの内側のpatterns

現在のRuleと現在のカーソル位置が基本状態

captureの内側のpatternについては、
スキャンの終了位置を内側に矯正する。
行末処理に似ている。

captureされた位置は事前に決まっているので、
開始位置にマッチするルールということになる。
Ruleからスキャンしたプランは現在のRuleがあれば求まるが、
マッチ位置は上流で決まるので、
スタックに入れておく必要がある。
なおかつそれが入れ子を組む場合がある。
[0]と[1]などが典型例。

// applyEndPatternLast


到達して離脱した後、
元のスタックで続きの処理を行いたいため、
それを状態として記述する必要がある

他に、状態として現在のスコープパスがある

初期スコープは、突入さえすればScopeRuleだが、
終了マッチが無い(ファイル終端)のが特殊。

スコープルールで
begin復帰後の処理が必要

ループを守るなら、
begin突入も一度ループに戻したいが・・・

begin復帰後、必要ならcontentNameを適用
end発見後、離脱

[begin] -- content -- [end]

end離脱後も区別が必要